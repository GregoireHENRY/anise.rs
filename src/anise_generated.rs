// automatically generated by the FlatBuffers compiler, do not modify



use crate::time_generated::*;
use crate::frames_generated::*;
use crate::orientation_generated::*;
use crate::common_generated::*;
use crate::ephemeris_generated::*;
use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod anise {

  use crate::time_generated::*;
  use crate::frames_generated::*;
  use crate::orientation_generated::*;
  use crate::common_generated::*;
  use crate::ephemeris_generated::*;
  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
    type Inner = Metadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Metadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Metadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataArgs<'args>) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
      let mut builder = MetadataBuilder::new(_fbb);
      if let Some(x) = args.comments { builder.add_comments(x); }
      if let Some(x) = args.publication_date { builder.add_publication_date(x); }
      if let Some(x) = args.publisher { builder.add_publisher(x); }
      builder.add_time_system(args.time_system);
      builder.finish()
    }

    pub const VT_PUBLISHER: flatbuffers::VOffsetT = 4;
    pub const VT_PUBLICATION_DATE: flatbuffers::VOffsetT = 6;
    pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 8;
    pub const VT_COMMENTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn publisher(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_PUBLISHER, None).unwrap()
  }
  #[inline]
  pub fn publication_date(&self) -> &'a time::Epoch {
    self._tab.get::<time::Epoch>(Metadata::VT_PUBLICATION_DATE, None).unwrap()
  }
  #[inline]
  pub fn time_system(&self) -> time::System {
    self._tab.get::<time::System>(Metadata::VT_TIME_SYSTEM, Some(time::System::TDB)).unwrap()
  }
  #[inline]
  pub fn comments(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_COMMENTS, None)
  }
}

impl flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"publisher", Self::VT_PUBLISHER, true)?
     .visit_field::<time::Epoch>(&"publication_date", Self::VT_PUBLICATION_DATE, true)?
     .visit_field::<time::System>(&"time_system", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"comments", Self::VT_COMMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub publisher: Option<flatbuffers::WIPOffset<&'a str>>,
    pub publication_date: Option<&'a time::Epoch>,
    pub time_system: time::System,
    pub comments: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataArgs {
            publisher: None, // required field
            publication_date: None, // required field
            time_system: time::System::TDB,
            comments: None,
        }
    }
}
pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher(&mut self, publisher: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_PUBLISHER, publisher);
  }
  #[inline]
  pub fn add_publication_date(&mut self, publication_date: &time::Epoch) {
    self.fbb_.push_slot_always::<&time::Epoch>(Metadata::VT_PUBLICATION_DATE, publication_date);
  }
  #[inline]
  pub fn add_time_system(&mut self, time_system: time::System) {
    self.fbb_.push_slot::<time::System>(Metadata::VT_TIME_SYSTEM, time_system, time::System::TDB);
  }
  #[inline]
  pub fn add_comments(&mut self, comments: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_COMMENTS, comments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Metadata::VT_PUBLISHER,"publisher");
    self.fbb_.required(o, Metadata::VT_PUBLICATION_DATE,"publication_date");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("publisher", &self.publisher());
      ds.field("publication_date", &self.publication_date());
      ds.field("time_system", &self.time_system());
      ds.field("comments", &self.comments());
      ds.finish()
  }
}
pub enum MapToIndexOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MapToIndex<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MapToIndex<'a> {
    type Inner = MapToIndex<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MapToIndex<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MapToIndex { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MapToIndexArgs<'args>) -> flatbuffers::WIPOffset<MapToIndex<'bldr>> {
      let mut builder = MapToIndexBuilder::new(_fbb);
      if let Some(x) = args.index { builder.add_index(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MapToIndex::VT_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(MapToIndex::VT_INDEX, None)
  }
}

impl flatbuffers::Verifiable for MapToIndex<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"hash", Self::VT_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(&"index", Self::VT_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct MapToIndexArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for MapToIndexArgs<'a> {
    #[inline]
    fn default() -> Self {
        MapToIndexArgs {
            hash: None,
            index: None,
        }
    }
}
pub struct MapToIndexBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MapToIndexBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MapToIndex::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MapToIndex::VT_INDEX, index);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapToIndexBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MapToIndexBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MapToIndex<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MapToIndex<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MapToIndex");
      ds.field("hash", &self.hash());
      ds.field("index", &self.index());
      ds.finish()
  }
}
pub enum AniseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Anise<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anise<'a> {
    type Inner = Anise<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Anise<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Anise { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AniseArgs<'args>) -> flatbuffers::WIPOffset<Anise<'bldr>> {
      let mut builder = AniseBuilder::new(_fbb);
      if let Some(x) = args.orientation_map { builder.add_orientation_map(x); }
      if let Some(x) = args.orientations { builder.add_orientations(x); }
      if let Some(x) = args.ephemeris_map { builder.add_ephemeris_map(x); }
      if let Some(x) = args.ephemerides { builder.add_ephemerides(x); }
      if let Some(x) = args.metadata { builder.add_metadata(x); }
      builder.finish()
    }

    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
    pub const VT_EPHEMERIDES: flatbuffers::VOffsetT = 6;
    pub const VT_EPHEMERIS_MAP: flatbuffers::VOffsetT = 8;
    pub const VT_ORIENTATIONS: flatbuffers::VOffsetT = 10;
    pub const VT_ORIENTATION_MAP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn metadata(&self) -> Metadata<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Metadata>>(Anise::VT_METADATA, None).unwrap()
  }
  #[inline]
  pub fn ephemerides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris>>>>(Anise::VT_EPHEMERIDES, None)
  }
  #[inline]
  pub fn ephemeris_map(&self) -> Option<MapToIndex<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MapToIndex>>(Anise::VT_EPHEMERIS_MAP, None)
  }
  #[inline]
  pub fn orientations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation>>>>(Anise::VT_ORIENTATIONS, None)
  }
  #[inline]
  pub fn orientation_map(&self) -> Option<MapToIndex<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MapToIndex>>(Anise::VT_ORIENTATION_MAP, None)
  }
}

impl flatbuffers::Verifiable for Anise<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(&"metadata", Self::VT_METADATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris>>>>(&"ephemerides", Self::VT_EPHEMERIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MapToIndex>>(&"ephemeris_map", Self::VT_EPHEMERIS_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<orientation::Orientation>>>>(&"orientations", Self::VT_ORIENTATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MapToIndex>>(&"orientation_map", Self::VT_ORIENTATION_MAP, false)?
     .finish();
    Ok(())
  }
}
pub struct AniseArgs<'a> {
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
    pub ephemerides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'a>>>>>,
    pub ephemeris_map: Option<flatbuffers::WIPOffset<MapToIndex<'a>>>,
    pub orientations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<orientation::Orientation<'a>>>>>,
    pub orientation_map: Option<flatbuffers::WIPOffset<MapToIndex<'a>>>,
}
impl<'a> Default for AniseArgs<'a> {
    #[inline]
    fn default() -> Self {
        AniseArgs {
            metadata: None, // required field
            ephemerides: None,
            ephemeris_map: None,
            orientations: None,
            orientation_map: None,
        }
    }
}
pub struct AniseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AniseBuilder<'a, 'b> {
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Anise::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_ephemerides(&mut self, ephemerides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemeris::Ephemeris<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anise::VT_EPHEMERIDES, ephemerides);
  }
  #[inline]
  pub fn add_ephemeris_map(&mut self, ephemeris_map: flatbuffers::WIPOffset<MapToIndex<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MapToIndex>>(Anise::VT_EPHEMERIS_MAP, ephemeris_map);
  }
  #[inline]
  pub fn add_orientations(&mut self, orientations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<orientation::Orientation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anise::VT_ORIENTATIONS, orientations);
  }
  #[inline]
  pub fn add_orientation_map(&mut self, orientation_map: flatbuffers::WIPOffset<MapToIndex<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MapToIndex>>(Anise::VT_ORIENTATION_MAP, orientation_map);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AniseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AniseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anise<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Anise::VT_METADATA,"metadata");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Anise<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Anise");
      ds.field("metadata", &self.metadata());
      ds.field("ephemerides", &self.ephemerides());
      ds.field("ephemeris_map", &self.ephemeris_map());
      ds.field("orientations", &self.orientations());
      ds.field("orientation_map", &self.orientation_map());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_anise<'a>(buf: &'a [u8]) -> Anise<'a> {
  unsafe { flatbuffers::root_unchecked::<Anise<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_anise<'a>(buf: &'a [u8]) -> Anise<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Anise<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Anise`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn root_as_anise(buf: &[u8]) -> Result<Anise, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Anise>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Anise` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_anise_unchecked`.
pub fn size_prefixed_root_as_anise(buf: &[u8]) -> Result<Anise, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Anise>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Anise` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn root_as_anise_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Anise<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Anise<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Anise` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_anise_unchecked`.
pub fn size_prefixed_root_as_anise_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Anise<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Anise<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Anise and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Anise`.
pub unsafe fn root_as_anise_unchecked(buf: &[u8]) -> Anise {
  flatbuffers::root_unchecked::<Anise>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Anise and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Anise`.
pub unsafe fn size_prefixed_root_as_anise_unchecked(buf: &[u8]) -> Anise {
  flatbuffers::size_prefixed_root_unchecked::<Anise>(buf)
}
pub const ANISE_IDENTIFIER: &str = "ANIS";

#[inline]
pub fn anise_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANISE_IDENTIFIER, false)
}

#[inline]
pub fn anise_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANISE_IDENTIFIER, true)
}

#[inline]
pub fn finish_anise_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Anise<'a>>) {
  fbb.finish(root, Some(ANISE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_anise_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Anise<'a>>) {
  fbb.finish_size_prefixed(root, Some(ANISE_IDENTIFIER));
}
}  // pub mod Anise

